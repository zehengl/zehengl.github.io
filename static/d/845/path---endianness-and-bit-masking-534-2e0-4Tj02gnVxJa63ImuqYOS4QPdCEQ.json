{"data":{"site":{"siteMetadata":{"title":"zehengl","author":"Zeheng Li"}},"markdownRemark":{"id":"ab134481-4128-5a6f-b386-b03174722812","excerpt":"Endianness See this  wiki  for background knowledge about endianness. It refers to the ordering of bytes. Big endianness is to store with the most significant…","html":"<h3>Endianness</h3>\n<p>See this <a href=\"https://en.wikipedia.org/wiki/Endianness\">wiki</a> for background knowledge about endianness. It refers to the ordering of bytes.</p>\n<ul>\n<li>Big endianness is to store with the most significant bit coming first.</li>\n<li>Little endianness is to store in the opposite order where the most significant bit comes last.</li>\n</ul>\n<p>For example, we have a <strong>hex</strong> number 0A0B0C0D</p>\n<p>Note that endianness talks about the order of <strong>bytes</strong></p>\n<p><em>0A0B0C0D</em> should be seperated into chunks with size of 8 bits</p>\n<p>that is, 0A | 0B | 0C | 0D</p>\n<p>In big endianness, it shall be written as 0A0B0C0D</p>\n<p>In little endianness, it shall be written as 0D0C0B0A</p>\n<h3>Python</h3>\n<p>Python provides a handy library (<strong>struct</strong>) to handle such conversion. See <a href=\"https://docs.python.org/2/library/struct.html\">here</a> for deatil.</p>\n<script src=\"https://gist.github.com/zehengl/1c592f9e3f3cc5797f03c02e8e953b28.js\"></script>\n<p><strong>Explanation:</strong></p>\n<p>Say, we want to create the big/little endian representation for three numbers: 1025, 2050, and 4099</p>\n<p>1025 = 1024 + 1, written in hex, it is 0x0401</p>\n<p>2050 = 2048 + 2, written in hex, it is 0x0802</p>\n<p>4099 = 4096 + 3, written in hex, it is 0x1003</p>\n<p>Using struct, we can <em>pack</em> these numbers with a formatted string “>hhh” or “>3h”</p>\n<ul>\n<li><strong>></strong> means big endian</li>\n<li><strong>h</strong> means short int, which is 2 byte or 16 bit</li>\n</ul>\n<p>Similarily, we can <em>pack</em> those numbers with a formatted string “&#x3C;hhh” or “&#x3C;3h”</p>\n<ul>\n<li><strong>&#x3C;</strong> means little endian</li>\n</ul>\n<p>Therefore, these three numbers are represented:</p>\n<ul>\n<li>in big endian, 040108021003</li>\n<li>in little endian, 010402080310</li>\n</ul>\n<p>In order to extract the numbers, we use <em>unpack</em> with the corresponding formatted string</p>\n<h3>Bit Masking</h3>\n<p>Bit level and/or/xor manipualtions</p>\n<p>and, take certain bits</p>\n<p>or, set certain bits</p>\n<p>xor, toggle certain bits</p>\n<p>For example, 1025 which is 0b10000000001</p>\n<p>take last two bits: 1025 &#x26; 0b11 = 0b1</p>\n<p>set last two bits: 1025 | 0b11 = 0b10000000111 = 1031</p>\n<p>toggle last two bits: 1025 ^ 0b11 = 0b10000000110 = 1030</p>","frontmatter":{"title":"Endianness and Bit Masking","date":"2016-06-09","description":"How to handle some bit level data manipualtions in Python."}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/endianness-and-bit-masking/","previous":{"fields":{"slug":"/agile-scrum-simulation-test/"},"frontmatter":{"title":"Agile Scrum Simulation Test"}},"next":{"fields":{"slug":"/string-to-qr-code/"},"frontmatter":{"title":"String to QR Code"}}}}